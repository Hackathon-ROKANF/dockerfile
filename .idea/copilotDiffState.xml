<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.dockerignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.dockerignore" />
              <option name="updatedContent" value="# Maven&#10;target/&#10;!target/*.jar&#10;!.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;# IDE&#10;.idea&#10;*.iws&#10;*.iml&#10;*.ipr&#10;.vscode/&#10;&#10;# OS&#10;.DS_Store&#10;Thumbs.db&#10;&#10;# Git&#10;.git&#10;.gitignore&#10;&#10;# Docker&#10;Dockerfile*&#10;docker-compose*&#10;&#10;# Documentation&#10;*.md&#10;!README.md&#10;&#10;# Logs&#10;logs/&#10;*.log&#10;&#10;# Temporary files&#10;*.tmp&#10;*.temp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/springboot/knockbe/BdsPlaywrightCrawler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/springboot/knockbe/BdsPlaywrightCrawler.java" />
              <option name="originalContent" value="package com.springboot.knockbe;&#10;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.microsoft.playwright.*;&#10;import com.microsoft.playwright.options.AriaRole;&#10;import com.microsoft.playwright.options.WaitForSelectorState;&#10;import com.microsoft.playwright.options.WaitUntilState;&#10;import jakarta.annotation.PostConstruct;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;@Component&#10;public class BdsPlaywrightCrawler {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(BdsPlaywrightCrawler.class);&#10;&#10;    @Value(&quot;${bds.base-url}&quot;)&#10;    private String baseUrl;&#10;&#10;    @Value(&quot;${bds.search-input-selectors:}&quot;)&#10;    private String searchSelectorsProp;&#10;&#10;    // 개선된 검색 셀렉터&#10;    private final List&lt;String&gt; searchSelectors = new ArrayList&lt;&gt;(List.of(&#10;            &quot;input[placeholder*=\&quot;주소\&quot;]&quot;,&#10;            &quot;input[placeholder*=\&quot;검색\&quot;]&quot;,&#10;            &quot;input[placeholder*=\&quot;지하철\&quot;]&quot;,&#10;            &quot;input[placeholder*=\&quot;단지\&quot;]&quot;,&#10;            &quot;input[type=\&quot;search\&quot;]&quot;,&#10;            &quot;input[type=\&quot;text\&quot;]&quot;,&#10;            &quot;#searchInput&quot;,&#10;            &quot;.search-input&quot;,&#10;            &quot;[data-testid=\&quot;search-input\&quot;]&quot;&#10;    ));&#10;&#10;    @Value(&quot;${bds.response-url-contains}&quot;)&#10;    private String respContains;&#10;&#10;    @Value(&quot;${bds.response-ends-with}&quot;)&#10;    private String respEndsWith;&#10;&#10;    @Value(&quot;${bds.timeout.page:20000}&quot;)&#10;    private int pageTimeout;&#10;&#10;    @Value(&quot;${bds.timeout.network-idle:12000}&quot;)&#10;    private int networkIdleWait;&#10;&#10;    private final ObjectMapper om = new ObjectMapper();&#10;&#10;    @PostConstruct&#10;    void initSelectors() {&#10;        if (searchSelectorsProp != null &amp;&amp; !searchSelectorsProp.isBlank()) {&#10;            for (String p : searchSelectorsProp.split(&quot;,&quot;)) {&#10;                String s = p.trim();&#10;                if (!s.isEmpty() &amp;&amp; !searchSelectors.contains(s)) searchSelectors.add(s);&#10;            }&#10;        }&#10;    }&#10;&#10;    public LowestPriceDto fetchLowestByAddress(String address) {&#10;        log.info(&quot;크롤링 시작: {}&quot;, address);&#10;&#10;        // 배포 환경 감지&#10;        boolean isDeployment = isDeploymentEnvironment();&#10;        log.info(&quot;배포 환경 감지: {}&quot;, isDeployment);&#10;&#10;        Playwright pw = null;&#10;        Browser browser = null;&#10;        BrowserContext context = null;&#10;        Page page = null;&#10;&#10;        try {&#10;            // Playwright 초기화 - 배포 환경에 최적화&#10;            pw = createPlaywright(isDeployment);&#10;&#10;            // 브라우저 실행 옵션 설정&#10;            List&lt;String&gt; args = getBrowserArgs(isDeployment);&#10;&#10;            log.info(&quot;브라우저 실행 시도 - 헤드리스 모드, 추가 옵션: {}&quot;, args.size());&#10;&#10;            browser = pw.chromium().launch(new BrowserType.LaunchOptions()&#10;                    .setHeadless(true)&#10;                    .setArgs(args)&#10;                    .setTimeout(isDeployment ? 60000 : 30000));&#10;&#10;            context = browser.newContext(new Browser.NewContextOptions()&#10;                    .setUserAgent(&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;)&#10;                    .setViewportSize(1920, 1080));&#10;&#10;            page = context.newPage();&#10;            page.setDefaultTimeout(8000);&#10;&#10;            // 네트워크 응답 모니터링&#10;            List&lt;String&gt; jsonResponses = Collections.synchronizedList(new ArrayList&lt;&gt;());&#10;            page.onResponse(response -&gt; {&#10;                String url = response.url();&#10;                if (url.contains(&quot;realprice&quot;) || url.contains(&quot;api&quot;) || url.contains(&quot;data&quot;)) {&#10;                    try {&#10;                        String body = response.text();&#10;                        if (body != null &amp;&amp; (body.contains(&quot;{&quot;) || body.contains(&quot;[&quot;))) {&#10;                            jsonResponses.add(body);&#10;                        }&#10;                    } catch (Exception e) {&#10;                        // 네트워크 응답 수집 실패는 무시&#10;                    }&#10;                }&#10;            });&#10;&#10;            // 1. 사이트 접속&#10;            page.navigate(baseUrl + &quot;/main.ytp&quot;, new Page.NavigateOptions()&#10;                    .setWaitUntil(WaitUntilState.DOMCONTENTLOADED)&#10;                    .setTimeout(8000));&#10;            safeWait(page, 500);&#10;&#10;            // 2. 검색 실행&#10;            if (!performSearch(page, address)) {&#10;                return createFallbackResponse(address, &quot;검색 실행 실패&quot;);&#10;            }&#10;&#10;            // 3. URL 분석 및 매매/전월세 URL 생성&#10;            String currentUrl = page.url();&#10;            log.info(&quot;검색 완료 URL: {}&quot;, currentUrl);&#10;&#10;            UrlPair urlPair = generateUrlPair(currentUrl);&#10;            if (urlPair == null) {&#10;                return createFallbackResponse(address, &quot;URL 패턴 분석 실패&quot;);&#10;            }&#10;&#10;            // 4. 매매 데이터 추출&#10;            Long saleLowest = extractPriceData(page, urlPair.saleUrl, &quot;매매&quot;, jsonResponses);&#10;&#10;            // 5. 전월세 데이터 추출&#10;            Long rentLowest = extractPriceData(page, urlPair.rentUrl, &quot;전월세&quot;, jsonResponses);&#10;&#10;            // 결과 DTO 생성&#10;            LowestPriceDto dto = new LowestPriceDto();&#10;            dto.setAddress(address);&#10;            dto.setSourceUrl(urlPair.saleUrl);&#10;            dto.setSaleLowestWon(saleLowest);&#10;            dto.setJeonseLowestWon(rentLowest);&#10;            dto.setWolseDepositLowestWon(null);&#10;            dto.setWolseMonthlyLowestWon(null);&#10;&#10;            log.info(&quot;크롤링 완료 - 매매: {}, 전월세: {}&quot;, saleLowest, rentLowest);&#10;            return dto;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;크롤링 오류: {}&quot;, e.getMessage(), e);&#10;            log.error(&quot;크롤링 오류 상세 정보 - 클래스: {}, 메시지: {}&quot;, e.getClass().getSimpleName(), e.getMessage());&#10;            return createFallbackResponse(address, &quot;크롤링 오류: &quot; + e.getMessage());&#10;        } finally {&#10;            cleanupResources(page, context, browser, pw);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 배포 환경에 최적화된 Playwright 생성&#10;     */&#10;    private Playwright createPlaywright(boolean isDeployment) {&#10;        try {&#10;            log.info(&quot;Playwright 초기화 시작...&quot;);&#10;&#10;            if (isDeployment) {&#10;                log.info(&quot;배포 환경 감지 - 환경 변수 설정&quot;);&#10;&#10;                // 배포 환경에서 브라우저 경로 강제 설정&#10;                String browsersPath = System.getenv(&quot;PLAYWRIGHT_BROWSERS_PATH&quot;);&#10;                if (browsersPath == null) {&#10;                    browsersPath = &quot;/root/.cache/ms-playwright&quot;;&#10;                    System.setProperty(&quot;PLAYWRIGHT_BROWSERS_PATH&quot;, browsersPath);&#10;                }&#10;&#10;                log.info(&quot;PLAYWRIGHT_BROWSERS_PATH: {}&quot;, browsersPath);&#10;                log.info(&quot;PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: {}&quot;, System.getenv(&quot;PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD&quot;));&#10;            }&#10;&#10;            Playwright playwright = Playwright.create();&#10;            log.info(&quot;Playwright 초기화 성공&quot;);&#10;            return playwright;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Playwright 생성 실패: {}&quot;, e.getMessage());&#10;            log.error(&quot;예외 상세:&quot;, e);&#10;&#10;            if (isDeployment) {&#10;                throw new RuntimeException(&quot;Playwright 초기화 실패 - 브라우저 바이너리를 찾을 수 없습니다&quot;, e);&#10;            } else {&#10;                throw new RuntimeException(&quot;Playwright 초기화 실패 - 로컬 환경에서 브라우저를 찾을 수 없습니다&quot;, e);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 브라우저 실행 인수 생성&#10;     */&#10;    private List&lt;String&gt; getBrowserArgs(boolean isDeployment) {&#10;        List&lt;String&gt; args = new ArrayList&lt;&gt;(List.of(&#10;            &quot;--no-sandbox&quot;,&#10;            &quot;--disable-dev-shm-usage&quot;,&#10;            &quot;--disable-gpu&quot;,&#10;            &quot;--disable-web-security&quot;,&#10;            &quot;--disable-features=VizDisplayCompositor&quot;,&#10;            &quot;--disable-background-timer-throttling&quot;,&#10;            &quot;--disable-backgrounding-occluded-windows&quot;,&#10;            &quot;--disable-renderer-backgrounding&quot;,&#10;            &quot;--disable-extensions&quot;,&#10;            &quot;--disable-plugins&quot;,&#10;            &quot;--disable-images&quot;,&#10;            &quot;--disable-java&quot;,&#10;            &quot;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;&#10;        ));&#10;&#10;        // 배포 환경에서 추가 최적화 옵션&#10;        if (isDeployment) {&#10;            args.addAll(List.of(&#10;                &quot;--single-process&quot;,&#10;                &quot;--no-zygote&quot;,&#10;                &quot;--disable-setuid-sandbox&quot;,&#10;                &quot;--disable-accelerated-2d-canvas&quot;,&#10;                &quot;--no-first-run&quot;,&#10;                &quot;--disable-default-apps&quot;,&#10;                &quot;--disable-sync&quot;,&#10;                &quot;--disable-translate&quot;,&#10;                &quot;--hide-scrollbars&quot;,&#10;                &quot;--metrics-recording-only&quot;,&#10;                &quot;--mute-audio&quot;,&#10;                &quot;--no-default-browser-check&quot;,&#10;                &quot;--no-pings&quot;,&#10;                &quot;--password-store=basic&quot;,&#10;                &quot;--use-mock-keychain&quot;,&#10;                &quot;--memory-pressure-off&quot;,&#10;                &quot;--max_old_space_size=4096&quot;&#10;            ));&#10;        }&#10;&#10;        return args;&#10;    }&#10;&#10;    /**&#10;     * 배포 환경 감지&#10;     */&#10;    private boolean isDeploymentEnvironment() {&#10;        String hostname = System.getenv(&quot;HOSTNAME&quot;);&#10;        String cloudtypeApp = System.getenv(&quot;CLOUDTYPE_APP_NAME&quot;);&#10;        String pwd = System.getenv(&quot;PWD&quot;);&#10;&#10;        return (hostname != null &amp;&amp; hostname.contains(&quot;knock&quot;)) ||&#10;               cloudtypeApp != null ||&#10;               (pwd != null &amp;&amp; pwd.equals(&quot;/app&quot;));&#10;    }&#10;&#10;    /**&#10;     * 검색 실행&#10;     */&#10;    private boolean performSearch(Page page, String address) {&#10;        try {&#10;            Locator input = findSearchInput(page);&#10;            if (input == null) {&#10;                log.error(&quot;검색 인풋을 찾지 못했습니다.&quot;);&#10;                return false;&#10;            }&#10;&#10;            input.fill(&quot;&quot;);&#10;            safeWait(page, 200);&#10;            input.fill(address);&#10;            safeWait(page, 300);&#10;&#10;            // 검색 실행&#10;            input.press(&quot;Enter&quot;);&#10;            safeWait(page, 200);&#10;&#10;            // 자동완성 선택&#10;            page.keyboard().press(&quot;ArrowDown&quot;);&#10;            safeWait(page, 200);&#10;            page.keyboard().press(&quot;Enter&quot;);&#10;&#10;            // 페이지 로딩 대기&#10;            safeWait(page, 1200);&#10;&#10;            return true;&#10;        } catch (Exception e) {&#10;            log.error(&quot;검색 실행 실패: {}&quot;, e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * URL 패턴 분석 및 매매/전월세 URL 생성&#10;     */&#10;    private UrlPair generateUrlPair(String currentUrl) {&#10;        try {&#10;            // URL 패턴: /map/realprice_map/{encoded_address}/N/{type}/{tab_number}/{price}.ytp&#10;            Pattern pattern = Pattern.compile(&quot;(/map/realprice_map/[^/]+/N/[ABC]/)([12])/([^/]+\\.ytp)&quot;);&#10;            Matcher matcher = pattern.matcher(currentUrl);&#10;&#10;            if (matcher.find()) {&#10;                String basePattern = matcher.group(1);&#10;                String suffix = matcher.group(3);&#10;&#10;                String saleUrl = baseUrl + basePattern + &quot;1/&quot; + suffix;&#10;                String rentUrl = baseUrl + basePattern + &quot;2/&quot; + suffix;&#10;&#10;                return new UrlPair(saleUrl, rentUrl);&#10;            }&#10;&#10;            log.warn(&quot;예상하지 못한 URL 패턴: {}&quot;, currentUrl);&#10;            return null;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;URL 생성 오류: {}&quot;, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 개선된 가격 데이터 추출&#10;     */&#10;    private Long extractPriceData(Page page, String targetUrl, String tabType, List&lt;String&gt; jsonResponses) {&#10;        try {&#10;            // 해당 탭 URL로 이동&#10;            page.navigate(targetUrl, new Page.NavigateOptions()&#10;                    .setWaitUntil(WaitUntilState.DOMCONTENTLOADED)&#10;                    .setTimeout(8000));&#10;            safeWait(page, 1000);&#10;&#10;            // 1순위: JSON 응답에서 추출&#10;            Long priceFromJson = extractPriceFromJson(jsonResponses, tabType);&#10;            if (priceFromJson != null &amp;&amp; priceFromJson &gt; 0) {&#10;                log.info(&quot;{} 가격 추출 성공 (JSON): {}&quot;, tabType, priceFromJson);&#10;                return priceFromJson;&#10;            }&#10;&#10;            // 2순위: DOM에서 추출&#10;            Long priceFromDom = extractPriceFromDOM(page, tabType);&#10;            if (priceFromDom != null &amp;&amp; priceFromDom &gt; 0) {&#10;                log.info(&quot;{} 가격 추출 성공 (DOM): {}&quot;, tabType, priceFromDom);&#10;                return priceFromDom;&#10;            }&#10;&#10;            log.warn(&quot;{} 탭에서 가격을 찾지 못했습니다&quot;, tabType);&#10;            return null;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;{} 데이터 추출 오류: {}&quot;, tabType, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * JSON 응답에서 가격 추출&#10;     */&#10;    private Long extractPriceFromJson(List&lt;String&gt; jsonResponses, String tabType) {&#10;        String targetType = getTabNumberFromTabType(tabType);&#10;&#10;        for (String json : jsonResponses) {&#10;            try {&#10;                JsonNode root = om.readTree(json);&#10;                Long price = scanJsonForPrice(root, targetType, tabType);&#10;                if (price != null &amp;&amp; price &gt; 0) {&#10;                    return price;&#10;                }&#10;            } catch (Exception e) {&#10;                // JSON 파싱 실패는 무시하고 다음 시도&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * JSON에서 가격 스캔&#10;     */&#10;    private Long scanJsonForPrice(JsonNode node, String targetType, String tabType) {&#10;        if (node == null || node.isNull()) return null;&#10;&#10;        if (node.isArray()) {&#10;            for (JsonNode item : node) {&#10;                Long result = scanJsonForPrice(item, targetType, tabType);&#10;                if (result != null) return result;&#10;            }&#10;        } else if (node.isObject()) {&#10;            // t_type 확인&#10;            JsonNode tTypeNode = node.get(&quot;t_type&quot;);&#10;            boolean typeMatches = (targetType == null) ||&#10;                                 (tTypeNode != null &amp;&amp; targetType.equals(tTypeNode.asText()));&#10;&#10;            if (typeMatches) {&#10;                // 가격 필드 탐색&#10;                String[] priceFields = getPriceFieldsForTabType(tabType);&#10;                for (String field : priceFields) {&#10;                    JsonNode priceNode = findFieldIgnoreCase(node, field);&#10;                    if (priceNode != null &amp;&amp; !priceNode.isNull()) {&#10;                        Long price = parsePrice(priceNode);&#10;                        if (price != null &amp;&amp; price &gt; 0) {&#10;                            return price;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 중첩 객체 탐색&#10;            Iterator&lt;JsonNode&gt; elements = node.elements();&#10;            while (elements.hasNext()) {&#10;                Long result = scanJsonForPrice(elements.next(), targetType, tabType);&#10;                if (result != null) return result;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * DOM 가격 추출&#10;     */&#10;    private Long extractPriceFromDOM(Page page, String tabType) {&#10;        try {&#10;            safeWait(page, 500);&#10;&#10;            // 방법 1: &quot;매물 최저가&quot; 라벨 기준으로 추출&#10;            Long price = extractByLowestPriceLabel(page);&#10;            if (price != null &amp;&amp; price &gt; 0) {&#10;                return price;&#10;            }&#10;&#10;            // 방법 2: price-info-area에서 추출&#10;            price = extractFromPriceInfoArea(page);&#10;            if (price != null &amp;&amp; price &gt; 0) {&#10;                return price;&#10;            }&#10;&#10;            // 방법 3: 화면의 모든 가격 중 유효한 첫 번째 선택&#10;            price = extractAnyValidPrice(page);&#10;            if (price != null &amp;&amp; price &gt; 0) {&#10;                return price;&#10;            }&#10;&#10;            return null;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;DOM 가격 추출 오류: {}&quot;, e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * &quot;매물 최저가&quot; 라벨 기준 추출&#10;     */&#10;    private Long extractByLowestPriceLabel(Page page) {&#10;        try {&#10;            Locator label = page.locator(&quot;*:has-text('매물 최저가')&quot;).first();&#10;            if (label.count() &gt; 0) {&#10;                Locator priceArea = label.locator(&quot;.. .price-info-area .price-area .txt, ../.. .price-info-area .price-area .txt&quot;);&#10;&#10;                if (priceArea.count() &gt; 0) {&#10;                    String priceText = priceArea.first().textContent().trim();&#10;                    if (!priceText.isEmpty() &amp;&amp; (priceText.contains(&quot;억&quot;) || priceText.contains(&quot;만&quot;))) {&#10;                        return MoneyParser.toWon(priceText);&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            // 실패 시 다음 방법 시도&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * price-info-area에서 추출&#10;     */&#10;    private Long extractFromPriceInfoArea(Page page) {&#10;        try {&#10;            Locator priceElements = page.locator(&quot;.price-info-area .price-area .txt:visible&quot;);&#10;            int count = priceElements.count();&#10;&#10;            for (int i = 0; i &lt; count; i++) {&#10;                String priceText = priceElements.nth(i).textContent().trim();&#10;                if (!priceText.isEmpty() &amp;&amp; (priceText.contains(&quot;억&quot;) || priceText.contains(&quot;만&quot;))) {&#10;                    Long price = MoneyParser.toWon(priceText);&#10;                    if (price != null &amp;&amp; price &gt; 0) {&#10;                        return price;&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            // 실패 시 다음 방법 시도&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * 화면의 모든 유효한 가격 중 첫 번째 선택&#10;     */&#10;    private Long extractAnyValidPrice(Page page) {&#10;        try {&#10;            String[] selectors = {&#10;                &quot;.price-area .txt&quot;,&#10;                &quot;.price .txt&quot;,&#10;                &quot;*:has-text('억')&quot;,&#10;                &quot;span:has-text('억')&quot;,&#10;                &quot;div:has-text('억')&quot;&#10;            };&#10;&#10;            for (String selector : selectors) {&#10;                try {&#10;                    Locator elements = page.locator(selector);&#10;                    int count = Math.min(elements.count(), 5);&#10;&#10;                    for (int i = 0; i &lt; count; i++) {&#10;                        String text = elements.nth(i).textContent().trim();&#10;                        if (text.contains(&quot;억&quot;) &amp;&amp; !text.contains(&quot;조&quot;)) {&#10;                            Long price = MoneyParser.toWon(text);&#10;                            if (price != null &amp;&amp; price &gt; 0) {&#10;                                return price;&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (Exception e) {&#10;                    // 해당 셀렉터 실패 시 다음 시도&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            // 모든 방법 실패&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // 유틸리티 메서드들&#10;    private String getTabNumberFromTabType(String tabType) {&#10;        return &quot;매매&quot;.equals(tabType) ? &quot;1&quot; : &quot;2&quot;;&#10;    }&#10;&#10;    private String[] getPriceFieldsForTabType(String tabType) {&#10;        if (&quot;매매&quot;.equals(tabType)) {&#10;            return new String[]{&quot;trade_price_min&quot;, &quot;sale_price_min&quot;, &quot;price_min&quot;};&#10;        } else {&#10;            return new String[]{&quot;trade_price_min&quot;, &quot;charter_price_min&quot;, &quot;jeonse_price_min&quot;, &quot;rent_deposit_min&quot;, &quot;price_min&quot;};&#10;        }&#10;    }&#10;&#10;    private JsonNode findFieldIgnoreCase(JsonNode node, String fieldName) {&#10;        Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = node.fields();&#10;        while (fields.hasNext()) {&#10;            Map.Entry&lt;String, JsonNode&gt; field = fields.next();&#10;            if (field.getKey().toLowerCase().contains(fieldName.toLowerCase())) {&#10;                return field.getValue();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private Long parsePrice(JsonNode priceNode) {&#10;        try {&#10;            if (priceNode.isNumber()) {&#10;                return priceNode.asLong() * 10_000L; // 만원 단위를 원 단위로&#10;            } else if (priceNode.isTextual()) {&#10;                return MoneyParser.toWon(priceNode.asText());&#10;            }&#10;        } catch (Exception e) {&#10;            // 파싱 실패 시 null 반환&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private void safeWait(Page page, long millis) {&#10;        try {&#10;            if (page != null &amp;&amp; !page.isClosed()) {&#10;                page.waitForTimeout(millis);&#10;            }&#10;        } catch (Exception e) {&#10;            try {&#10;                Thread.sleep(millis);&#10;            } catch (InterruptedException ie) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    private LowestPriceDto createFallbackResponse(String address, String errorMessage) {&#10;        log.warn(&quot;크롤링 실패: {}&quot;, errorMessage);&#10;        LowestPriceDto dto = new LowestPriceDto();&#10;        dto.setAddress(address);&#10;        dto.setSourceUrl(&quot;크롤링 실패: &quot; + errorMessage);&#10;        dto.setSaleLowestWon(null);&#10;        dto.setJeonseLowestWon(null);&#10;        dto.setWolseDepositLowestWon(null);&#10;        dto.setWolseMonthlyLowestWon(null);&#10;        return dto;&#10;    }&#10;&#10;    private void cleanupResources(Page page, BrowserContext context, Browser browser, Playwright pw) {&#10;        try { if (page != null &amp;&amp; !page.isClosed()) page.close(); } catch (Exception e) {}&#10;        try { if (context != null) context.close(); } catch (Exception e) {}&#10;        try { if (browser != null) browser.close(); } catch (Exception e) {}&#10;        try { if (pw != null) pw.close(); } catch (Exception e) {}&#10;    }&#10;&#10;    private Locator findSearchInput(Page page) {&#10;        // 1) 메인 프레임 후보 셀렉터&#10;        Locator found = trySelectorsOn(page);&#10;        if (found != null) return found;&#10;&#10;        // 2) placeholder 기반 검색&#10;        try {&#10;            Locator byPlaceholder = page.getByPlaceholder(Pattern.compile(&quot;주소|검색|지하철|단지&quot;));&#10;            if (byPlaceholder.count() &gt; 0) return byPlaceholder.first();&#10;        } catch (Exception e) {}&#10;&#10;        // 3) role 기반 검색&#10;        try {&#10;            Locator byRole = page.getByRole(AriaRole.TEXTBOX, new Page.GetByRoleOptions().setName(Pattern.compile(&quot;주소|검색|지하철|단지&quot;)));&#10;            if (byRole.count() &gt; 0) return byRole.first();&#10;        } catch (Exception e) {}&#10;&#10;        return null;&#10;    }&#10;&#10;    private Locator trySelectorsOn(Page page) {&#10;        for (String sel : searchSelectors) {&#10;            try {&#10;                Locator loc = page.locator(sel);&#10;                if (loc.count() &gt; 0) {&#10;                    Locator first = loc.first();&#10;                    try {&#10;                        first.waitFor(new Locator.WaitForOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(3000));&#10;                    } catch (Exception ignore) {}&#10;                    if (first.isVisible()) return first;&#10;                }&#10;            } catch (Exception ignore) {}&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // URL 쌍을 담는 내부 클래스&#10;    private static class UrlPair {&#10;        final String saleUrl;&#10;        final String rentUrl;&#10;&#10;        UrlPair(String saleUrl, String rentUrl) {&#10;            this.saleUrl = saleUrl;&#10;            this.rentUrl = rentUrl;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.springboot.knockbe;&#13;&#10;&#13;&#10;import com.fasterxml.jackson.databind.JsonNode;&#13;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#13;&#10;import com.microsoft.playwright.*;&#13;&#10;import com.microsoft.playwright.options.AriaRole;&#13;&#10;import com.microsoft.playwright.options.WaitForSelectorState;&#13;&#10;import com.microsoft.playwright.options.WaitUntilState;&#13;&#10;import jakarta.annotation.PostConstruct;&#13;&#10;import org.slf4j.Logger;&#13;&#10;import org.slf4j.LoggerFactory;&#13;&#10;import org.springframework.beans.factory.annotation.Value;&#13;&#10;import org.springframework.stereotype.Component;&#13;&#10;&#13;&#10;import java.util.*;&#13;&#10;import java.util.regex.Matcher;&#13;&#10;import java.util.regex.Pattern;&#13;&#10;&#13;&#10;@Component&#13;&#10;public class BdsPlaywrightCrawler {&#13;&#10;&#13;&#10;    private static final Logger log = LoggerFactory.getLogger(BdsPlaywrightCrawler.class);&#13;&#10;&#13;&#10;    @Value(&quot;${bds.base-url}&quot;)&#13;&#10;    private String baseUrl;&#13;&#10;&#13;&#10;    @Value(&quot;${bds.search-input-selectors:}&quot;)&#13;&#10;    private String searchSelectorsProp;&#13;&#10;&#13;&#10;    // 개선된 검색 셀렉터&#13;&#10;    private final List&lt;String&gt; searchSelectors = new ArrayList&lt;&gt;(List.of(&#13;&#10;            &quot;input[placeholder*=\&quot;주소\&quot;]&quot;,&#13;&#10;            &quot;input[placeholder*=\&quot;검색\&quot;]&quot;,&#13;&#10;            &quot;input[placeholder*=\&quot;지하철\&quot;]&quot;,&#13;&#10;            &quot;input[placeholder*=\&quot;단지\&quot;]&quot;,&#13;&#10;            &quot;input[type=\&quot;search\&quot;]&quot;,&#13;&#10;            &quot;input[type=\&quot;text\&quot;]&quot;,&#13;&#10;            &quot;#searchInput&quot;,&#13;&#10;            &quot;.search-input&quot;,&#13;&#10;            &quot;[data-testid=\&quot;search-input\&quot;]&quot;&#13;&#10;    ));&#13;&#10;&#13;&#10;    @Value(&quot;${bds.response-url-contains}&quot;)&#13;&#10;    private String respContains;&#13;&#10;&#13;&#10;    @Value(&quot;${bds.response-ends-with}&quot;)&#13;&#10;    private String respEndsWith;&#13;&#10;&#13;&#10;    @Value(&quot;${bds.timeout.page:20000}&quot;)&#13;&#10;    private int pageTimeout;&#13;&#10;&#13;&#10;    @Value(&quot;${bds.timeout.network-idle:12000}&quot;)&#13;&#10;    private int networkIdleWait;&#13;&#10;&#13;&#10;    private final ObjectMapper om = new ObjectMapper();&#13;&#10;&#13;&#10;    @PostConstruct&#13;&#10;    void initSelectors() {&#13;&#10;        if (searchSelectorsProp != null &amp;&amp; !searchSelectorsProp.isBlank()) {&#13;&#10;            for (String p : searchSelectorsProp.split(&quot;,&quot;)) {&#13;&#10;                String s = p.trim();&#13;&#10;                if (!s.isEmpty() &amp;&amp; !searchSelectors.contains(s)) searchSelectors.add(s);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public LowestPriceDto fetchLowestByAddress(String address) {&#13;&#10;        log.info(&quot;크롤링 시작: {}&quot;, address);&#13;&#10;&#13;&#10;        // 배포 환경 감지&#13;&#10;        boolean isDeployment = isDeploymentEnvironment();&#13;&#10;        log.info(&quot;배포 환경 감지: {}&quot;, isDeployment);&#13;&#10;&#13;&#10;        Playwright pw = null;&#13;&#10;        Browser browser = null;&#13;&#10;        BrowserContext context = null;&#13;&#10;        Page page = null;&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Playwright 초기화 - 배포 환경에 최적화&#13;&#10;            pw = createPlaywright(isDeployment);&#13;&#10;&#13;&#10;            // 브라우저 실행 옵션 설정&#13;&#10;            List&lt;String&gt; args = getBrowserArgs(isDeployment);&#13;&#10;&#13;&#10;            log.info(&quot;브라우저 실행 시도 - 헤드리스 모드, 추가 옵션: {}&quot;, args.size());&#13;&#10;&#13;&#10;            browser = pw.chromium().launch(new BrowserType.LaunchOptions()&#13;&#10;                    .setHeadless(true)&#13;&#10;                    .setArgs(args)&#13;&#10;                    .setTimeout(isDeployment ? 60000 : 30000));&#13;&#10;&#13;&#10;            context = browser.newContext(new Browser.NewContextOptions()&#13;&#10;                    .setUserAgent(&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;)&#13;&#10;                    .setViewportSize(1920, 1080));&#13;&#10;&#13;&#10;            page = context.newPage();&#13;&#10;            page.setDefaultTimeout(8000);&#13;&#10;&#13;&#10;            // 네트워크 응답 모니터링&#13;&#10;            List&lt;String&gt; jsonResponses = Collections.synchronizedList(new ArrayList&lt;&gt;());&#13;&#10;            page.onResponse(response -&gt; {&#13;&#10;                String url = response.url();&#13;&#10;                if (url.contains(&quot;realprice&quot;) || url.contains(&quot;api&quot;) || url.contains(&quot;data&quot;)) {&#13;&#10;                    try {&#13;&#10;                        String body = response.text();&#13;&#10;                        if (body != null &amp;&amp; (body.contains(&quot;{&quot;) || body.contains(&quot;[&quot;))) {&#13;&#10;                            jsonResponses.add(body);&#13;&#10;                        }&#13;&#10;                    } catch (Exception e) {&#13;&#10;                        // 네트워크 응답 수집 실패는 무시&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            });&#13;&#10;&#13;&#10;            // 1. 사이트 접속&#13;&#10;            page.navigate(baseUrl + &quot;/main.ytp&quot;, new Page.NavigateOptions()&#13;&#10;                    .setWaitUntil(WaitUntilState.DOMCONTENTLOADED)&#13;&#10;                    .setTimeout(8000));&#13;&#10;            safeWait(page, 500);&#13;&#10;&#13;&#10;            // 2. 검색 실행&#13;&#10;            if (!performSearch(page, address)) {&#13;&#10;                return createFallbackResponse(address, &quot;검색 실행 실패&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            // 3. URL 분석 및 매매/전월세 URL 생성&#13;&#10;            String currentUrl = page.url();&#13;&#10;            log.info(&quot;검색 완료 URL: {}&quot;, currentUrl);&#13;&#10;&#13;&#10;            UrlPair urlPair = generateUrlPair(currentUrl);&#13;&#10;            if (urlPair == null) {&#13;&#10;                return createFallbackResponse(address, &quot;URL 패턴 분석 실패&quot;);&#13;&#10;            }&#13;&#10;&#13;&#10;            // 4. 매매 데이터 추출&#13;&#10;            Long saleLowest = extractPriceData(page, urlPair.saleUrl, &quot;매매&quot;, jsonResponses);&#13;&#10;&#13;&#10;            // 5. 전월세 데이터 추출&#13;&#10;            Long rentLowest = extractPriceData(page, urlPair.rentUrl, &quot;전월세&quot;, jsonResponses);&#13;&#10;&#13;&#10;            // 결과 DTO 생성&#13;&#10;            LowestPriceDto dto = new LowestPriceDto();&#13;&#10;            dto.setAddress(address);&#13;&#10;            dto.setSourceUrl(urlPair.saleUrl);&#13;&#10;            dto.setSaleLowestWon(saleLowest);&#13;&#10;            dto.setJeonseLowestWon(rentLowest);&#13;&#10;            dto.setWolseDepositLowestWon(null);&#13;&#10;            dto.setWolseMonthlyLowestWon(null);&#13;&#10;&#13;&#10;            log.info(&quot;크롤링 완료 - 매매: {}, 전월세: {}&quot;, saleLowest, rentLowest);&#13;&#10;            return dto;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;크롤링 오류: {}&quot;, e.getMessage(), e);&#13;&#10;            log.error(&quot;크롤링 오류 상세 정보 - 클래스: {}, 메시지: {}&quot;, e.getClass().getSimpleName(), e.getMessage());&#13;&#10;            return createFallbackResponse(address, &quot;크롤링 오류: &quot; + e.getMessage());&#13;&#10;        } finally {&#13;&#10;            cleanupResources(page, context, browser, pw);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 배포 환경에 최적화된 Playwright 생성&#13;&#10;     */&#13;&#10;    private Playwright createPlaywright(boolean isDeployment) {&#13;&#10;        try {&#13;&#10;            log.info(&quot;Playwright 초기화 시작...&quot;);&#13;&#10;&#13;&#10;            if (isDeployment) {&#13;&#10;                log.info(&quot;배포 환경 감지 - 환경 변수 설정&quot;);&#13;&#10;&#13;&#10;                // 배포 환경에서 브라우저 경로 강제 설정&#13;&#10;                String browsersPath = System.getenv(&quot;PLAYWRIGHT_BROWSERS_PATH&quot;);&#13;&#10;                if (browsersPath == null) {&#13;&#10;                    browsersPath = &quot;/root/.cache/ms-playwright&quot;;&#13;&#10;                    System.setProperty(&quot;PLAYWRIGHT_BROWSERS_PATH&quot;, browsersPath);&#13;&#10;                }&#13;&#10;&#13;&#10;                log.info(&quot;PLAYWRIGHT_BROWSERS_PATH: {}&quot;, browsersPath);&#13;&#10;                log.info(&quot;PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: {}&quot;, System.getenv(&quot;PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD&quot;));&#13;&#10;            }&#13;&#10;&#13;&#10;            Playwright playwright = Playwright.create();&#13;&#10;            log.info(&quot;Playwright 초기화 성공&quot;);&#13;&#10;            return playwright;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;Playwright 생성 실패: {}&quot;, e.getMessage());&#13;&#10;            log.error(&quot;예외 상세:&quot;, e);&#13;&#10;&#13;&#10;            if (isDeployment) {&#13;&#10;                throw new RuntimeException(&quot;Playwright 초기화 실패 - 브라우저 바이너리를 찾을 수 없습니다&quot;, e);&#13;&#10;            } else {&#13;&#10;                throw new RuntimeException(&quot;Playwright 초기화 실패 - 로컬 환경에서 브라우저를 찾을 수 없습니다&quot;, e);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 브라우저 실행 인수 생성&#13;&#10;     */&#13;&#10;    private List&lt;String&gt; getBrowserArgs(boolean isDeployment) {&#13;&#10;        List&lt;String&gt; args = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        // 기본 보안 및 안정성 옵션&#13;&#10;        args.add(&quot;--no-sandbox&quot;);&#13;&#10;        args.add(&quot;--disable-setuid-sandbox&quot;);&#13;&#10;        args.add(&quot;--disable-dev-shm-usage&quot;);&#13;&#10;        args.add(&quot;--disable-gpu&quot;);&#13;&#10;        args.add(&quot;--no-first-run&quot;);&#13;&#10;        args.add(&quot;--no-default-browser-check&quot;);&#13;&#10;        args.add(&quot;--disable-default-apps&quot;);&#13;&#10;&#13;&#10;        if (isDeployment) {&#13;&#10;            // 배포 환경 추가 옵션&#13;&#10;            args.add(&quot;--disable-background-timer-throttling&quot;);&#13;&#10;            args.add(&quot;--disable-backgrounding-occluded-windows&quot;);&#13;&#10;            args.add(&quot;--disable-renderer-backgrounding&quot;);&#13;&#10;            args.add(&quot;--disable-features=TranslateUI&quot;);&#13;&#10;            args.add(&quot;--disable-ipc-flooding-protection&quot;);&#13;&#10;            args.add(&quot;--single-process&quot;);&#13;&#10;            args.add(&quot;--memory-pressure-off&quot;);&#13;&#10;            args.add(&quot;--max_old_space_size=4096&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return args;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 배포 환경 감지&#13;&#10;     */&#13;&#10;    private boolean isDeploymentEnvironment() {&#13;&#10;        // Docker 환경 감지&#13;&#10;        if (System.getenv(&quot;DOCKER_CONTAINER&quot;) != null ||&#13;&#10;                new java.io.File(&quot;/.dockerenv&quot;).exists()) {&#13;&#10;            return true;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Spring Profile 확인&#13;&#10;        String profiles = System.getProperty(&quot;spring.profiles.active&quot;);&#13;&#10;        if (profiles != null &amp;&amp; profiles.contains(&quot;prod&quot;)) {&#13;&#10;            return true;&#13;&#10;        }&#13;&#10;&#13;&#10;        // CI/CD 환경 감지&#13;&#10;        return System.getenv(&quot;CI&quot;) != null ||&#13;&#10;                System.getenv(&quot;GITHUB_ACTIONS&quot;) != null ||&#13;&#10;                System.getenv(&quot;JENKINS_URL&quot;) != null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 검색 실행&#13;&#10;     */&#13;&#10;    private boolean performSearch(Page page, String address) {&#13;&#10;        try {&#13;&#10;            Locator input = findSearchInput(page);&#13;&#10;            if (input == null) {&#13;&#10;                log.error(&quot;검색 인풋을 찾지 못했습니다.&quot;);&#13;&#10;                return false;&#13;&#10;            }&#13;&#10;&#13;&#10;            input.fill(&quot;&quot;);&#13;&#10;            safeWait(page, 200);&#13;&#10;            input.fill(address);&#13;&#10;            safeWait(page, 300);&#13;&#10;&#13;&#10;            // 검색 실행&#13;&#10;            input.press(&quot;Enter&quot;);&#13;&#10;            safeWait(page, 200);&#13;&#10;&#13;&#10;            // 자동완성 선택&#13;&#10;            page.keyboard().press(&quot;ArrowDown&quot;);&#13;&#10;            safeWait(page, 200);&#13;&#10;            page.keyboard().press(&quot;Enter&quot;);&#13;&#10;&#13;&#10;            // 페이지 로딩 대기&#13;&#10;            safeWait(page, 1200);&#13;&#10;&#13;&#10;            return true;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;검색 실행 실패: {}&quot;, e.getMessage());&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * URL 패턴 분석 및 매매/전월세 URL 생성&#13;&#10;     */&#13;&#10;    private UrlPair generateUrlPair(String currentUrl) {&#13;&#10;        try {&#13;&#10;            // URL 패턴: /map/realprice_map/{encoded_address}/N/{type}/{tab_number}/{price}.ytp&#13;&#10;            Pattern pattern = Pattern.compile(&quot;(/map/realprice_map/[^/]+/N/[ABC]/)([12])/([^/]+\\.ytp)&quot;);&#13;&#10;            Matcher matcher = pattern.matcher(currentUrl);&#13;&#10;&#13;&#10;            if (matcher.find()) {&#13;&#10;                String basePattern = matcher.group(1);&#13;&#10;                String suffix = matcher.group(3);&#13;&#10;&#13;&#10;                String saleUrl = baseUrl + basePattern + &quot;1/&quot; + suffix;&#13;&#10;                String rentUrl = baseUrl + basePattern + &quot;2/&quot; + suffix;&#13;&#10;&#13;&#10;                return new UrlPair(saleUrl, rentUrl);&#13;&#10;            }&#13;&#10;&#13;&#10;            log.warn(&quot;예상하지 못한 URL 패턴: {}&quot;, currentUrl);&#13;&#10;            return null;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;URL 생성 오류: {}&quot;, e.getMessage());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 개선된 가격 데이터 추출&#13;&#10;     */&#13;&#10;    private Long extractPriceData(Page page, String targetUrl, String tabType, List&lt;String&gt; jsonResponses) {&#13;&#10;        try {&#13;&#10;            // 해당 탭 URL로 이동&#13;&#10;            page.navigate(targetUrl, new Page.NavigateOptions()&#13;&#10;                    .setWaitUntil(WaitUntilState.DOMCONTENTLOADED)&#13;&#10;                    .setTimeout(8000));&#13;&#10;            safeWait(page, 1000);&#13;&#10;&#13;&#10;            // 1순위: JSON 응답에서 추출&#13;&#10;            Long priceFromJson = extractPriceFromJson(jsonResponses, tabType);&#13;&#10;            if (priceFromJson != null &amp;&amp; priceFromJson &gt; 0) {&#13;&#10;                log.info(&quot;{} 가격 추출 성공 (JSON): {}&quot;, tabType, priceFromJson);&#13;&#10;                return priceFromJson;&#13;&#10;            }&#13;&#10;&#13;&#10;            // 2순위: DOM에서 추출&#13;&#10;            Long priceFromDom = extractPriceFromDOM(page, tabType);&#13;&#10;            if (priceFromDom != null &amp;&amp; priceFromDom &gt; 0) {&#13;&#10;                log.info(&quot;{} 가격 추출 성공 (DOM): {}&quot;, tabType, priceFromDom);&#13;&#10;                return priceFromDom;&#13;&#10;            }&#13;&#10;&#13;&#10;            log.warn(&quot;{} 탭에서 가격을 찾지 못했습니다&quot;, tabType);&#13;&#10;            return null;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;{} 데이터 추출 오류: {}&quot;, tabType, e.getMessage());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * JSON 응답에서 가격 추출&#13;&#10;     */&#13;&#10;    private Long extractPriceFromJson(List&lt;String&gt; jsonResponses, String tabType) {&#13;&#10;        String targetType = getTabNumberFromTabType(tabType);&#13;&#10;&#13;&#10;        for (String json : jsonResponses) {&#13;&#10;            try {&#13;&#10;                JsonNode root = om.readTree(json);&#13;&#10;                Long price = scanJsonForPrice(root, targetType, tabType);&#13;&#10;                if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                    return price;&#13;&#10;                }&#13;&#10;            } catch (Exception e) {&#13;&#10;                // JSON 파싱 실패는 무시하고 다음 시도&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * JSON에서 가격 스캔&#13;&#10;     */&#13;&#10;    private Long scanJsonForPrice(JsonNode node, String targetType, String tabType) {&#13;&#10;        if (node == null || node.isNull()) return null;&#13;&#10;&#13;&#10;        if (node.isArray()) {&#13;&#10;            for (JsonNode item : node) {&#13;&#10;                Long result = scanJsonForPrice(item, targetType, tabType);&#13;&#10;                if (result != null) return result;&#13;&#10;            }&#13;&#10;        } else if (node.isObject()) {&#13;&#10;            // t_type 확인&#13;&#10;            JsonNode tTypeNode = node.get(&quot;t_type&quot;);&#13;&#10;            boolean typeMatches = (targetType == null) ||&#13;&#10;                    (tTypeNode != null &amp;&amp; targetType.equals(tTypeNode.asText()));&#13;&#10;&#13;&#10;            if (typeMatches) {&#13;&#10;                // 가격 필드 탐색&#13;&#10;                String[] priceFields = getPriceFieldsForTabType(tabType);&#13;&#10;                for (String field : priceFields) {&#13;&#10;                    JsonNode priceNode = findFieldIgnoreCase(node, field);&#13;&#10;                    if (priceNode != null &amp;&amp; !priceNode.isNull()) {&#13;&#10;                        Long price = parsePrice(priceNode);&#13;&#10;                        if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                            return price;&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // 중첩 객체 탐색&#13;&#10;            Iterator&lt;JsonNode&gt; elements = node.elements();&#13;&#10;            while (elements.hasNext()) {&#13;&#10;                Long result = scanJsonForPrice(elements.next(), targetType, tabType);&#13;&#10;                if (result != null) return result;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * DOM 가격 추출&#13;&#10;     */&#13;&#10;    private Long extractPriceFromDOM(Page page, String tabType) {&#13;&#10;        try {&#13;&#10;            safeWait(page, 500);&#13;&#10;&#13;&#10;            // 방법 1: &quot;매물 최저가&quot; 라벨 기준으로 추출&#13;&#10;            Long price = extractByLowestPriceLabel(page);&#13;&#10;            if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                return price;&#13;&#10;            }&#13;&#10;&#13;&#10;            // 방법 2: price-info-area에서 추출&#13;&#10;            price = extractFromPriceInfoArea(page);&#13;&#10;            if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                return price;&#13;&#10;            }&#13;&#10;&#13;&#10;            // 방법 3: 화면의 모든 가격 중 유효한 첫 번째 선택&#13;&#10;            price = extractAnyValidPrice(page);&#13;&#10;            if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                return price;&#13;&#10;            }&#13;&#10;&#13;&#10;            return null;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            log.error(&quot;DOM 가격 추출 오류: {}&quot;, e.getMessage());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * &quot;매물 최저가&quot; 라벨 기준 추출&#13;&#10;     */&#13;&#10;    private Long extractByLowestPriceLabel(Page page) {&#13;&#10;        try {&#13;&#10;            Locator label = page.locator(&quot;*:has-text('매물 최저가')&quot;).first();&#13;&#10;            if (label.count() &gt; 0) {&#13;&#10;                Locator priceArea = label.locator(&quot;.. .price-info-area .price-area .txt, ../.. .price-info-area .price-area .txt&quot;);&#13;&#10;&#13;&#10;                if (priceArea.count() &gt; 0) {&#13;&#10;                    String priceText = priceArea.first().textContent().trim();&#13;&#10;                    if (!priceText.isEmpty() &amp;&amp; (priceText.contains(&quot;억&quot;) || priceText.contains(&quot;만&quot;))) {&#13;&#10;                        return MoneyParser.toWon(priceText);&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // 실패 시 다음 방법 시도&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * price-info-area에서 추출&#13;&#10;     */&#13;&#10;    private Long extractFromPriceInfoArea(Page page) {&#13;&#10;        try {&#13;&#10;            Locator priceElements = page.locator(&quot;.price-info-area .price-area .txt:visible&quot;);&#13;&#10;            int count = priceElements.count();&#13;&#10;&#13;&#10;            for (int i = 0; i &lt; count; i++) {&#13;&#10;                String priceText = priceElements.nth(i).textContent().trim();&#13;&#10;                if (!priceText.isEmpty() &amp;&amp; (priceText.contains(&quot;억&quot;) || priceText.contains(&quot;만&quot;))) {&#13;&#10;                    Long price = MoneyParser.toWon(priceText);&#13;&#10;                    if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                        return price;&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // 실패 시 다음 방법 시도&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 화면의 모든 유효한 가격 중 첫 번째 선택&#13;&#10;     */&#13;&#10;    private Long extractAnyValidPrice(Page page) {&#13;&#10;        try {&#13;&#10;            String[] selectors = {&#13;&#10;                    &quot;.price-area .txt&quot;,&#13;&#10;                    &quot;.price .txt&quot;,&#13;&#10;                    &quot;*:has-text('억')&quot;,&#13;&#10;                    &quot;span:has-text('억')&quot;,&#13;&#10;                    &quot;div:has-text('억')&quot;&#13;&#10;            };&#13;&#10;&#13;&#10;            for (String selector : selectors) {&#13;&#10;                try {&#13;&#10;                    Locator elements = page.locator(selector);&#13;&#10;                    int count = Math.min(elements.count(), 5);&#13;&#10;&#13;&#10;                    for (int i = 0; i &lt; count; i++) {&#13;&#10;                        String text = elements.nth(i).textContent().trim();&#13;&#10;                        if (text.contains(&quot;억&quot;) &amp;&amp; !text.contains(&quot;조&quot;)) {&#13;&#10;                            Long price = MoneyParser.toWon(text);&#13;&#10;                            if (price != null &amp;&amp; price &gt; 0) {&#13;&#10;                                return price;&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                } catch (Exception e) {&#13;&#10;                    // 해당 셀렉터 실패 시 다음 시도&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // 모든 방법 실패&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    // 유틸리티 메서드들&#13;&#10;    private String getTabNumberFromTabType(String tabType) {&#13;&#10;        return &quot;매매&quot;.equals(tabType) ? &quot;1&quot; : &quot;2&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    private String[] getPriceFieldsForTabType(String tabType) {&#13;&#10;        if (&quot;매매&quot;.equals(tabType)) {&#13;&#10;            return new String[]{&quot;trade_price_min&quot;, &quot;sale_price_min&quot;, &quot;price_min&quot;};&#13;&#10;        } else {&#13;&#10;            return new String[]{&quot;trade_price_min&quot;, &quot;charter_price_min&quot;, &quot;jeonse_price_min&quot;, &quot;rent_deposit_min&quot;, &quot;price_min&quot;};&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private JsonNode findFieldIgnoreCase(JsonNode node, String fieldName) {&#13;&#10;        Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = node.fields();&#13;&#10;        while (fields.hasNext()) {&#13;&#10;            Map.Entry&lt;String, JsonNode&gt; field = fields.next();&#13;&#10;            if (field.getKey().toLowerCase().contains(fieldName.toLowerCase())) {&#13;&#10;                return field.getValue();&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    private Long parsePrice(JsonNode priceNode) {&#13;&#10;        try {&#13;&#10;            if (priceNode.isNumber()) {&#13;&#10;                return priceNode.asLong() * 10_000L; // 만원 단위를 원 단위로&#13;&#10;            } else if (priceNode.isTextual()) {&#13;&#10;                return MoneyParser.toWon(priceNode.asText());&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            // 파싱 실패 시 null 반환&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    private void safeWait(Page page, long millis) {&#13;&#10;        try {&#13;&#10;            if (page != null &amp;&amp; !page.isClosed()) {&#13;&#10;                page.waitForTimeout(millis);&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            try {&#13;&#10;                Thread.sleep(millis);&#13;&#10;            } catch (InterruptedException ie) {&#13;&#10;                Thread.currentThread().interrupt();&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private LowestPriceDto createFallbackResponse(String address, String errorMessage) {&#13;&#10;        log.warn(&quot;크롤링 실패: {}&quot;, errorMessage);&#13;&#10;        LowestPriceDto dto = new LowestPriceDto();&#13;&#10;        dto.setAddress(address);&#13;&#10;        dto.setSourceUrl(&quot;크롤링 실패: &quot; + errorMessage);&#13;&#10;        dto.setSaleLowestWon(null);&#13;&#10;        dto.setJeonseLowestWon(null);&#13;&#10;        dto.setWolseDepositLowestWon(null);&#13;&#10;        dto.setWolseMonthlyLowestWon(null);&#13;&#10;        return dto;&#13;&#10;    }&#13;&#10;&#13;&#10;    private void cleanupResources(Page page, BrowserContext context, Browser browser, Playwright pw) {&#13;&#10;        try { if (page != null &amp;&amp; !page.isClosed()) page.close(); } catch (Exception e) {}&#13;&#10;        try { if (context != null) context.close(); } catch (Exception e) {}&#13;&#10;        try { if (browser != null) browser.close(); } catch (Exception e) {}&#13;&#10;        try { if (pw != null) pw.close(); } catch (Exception e) {}&#13;&#10;    }&#13;&#10;&#13;&#10;    private Locator findSearchInput(Page page) {&#13;&#10;        // 1) 메인 프레임 후보 셀렉터&#13;&#10;        Locator found = trySelectorsOn(page);&#13;&#10;        if (found != null) return found;&#13;&#10;&#13;&#10;        // 2) placeholder 기반 검색&#13;&#10;        try {&#13;&#10;            Locator byPlaceholder = page.getByPlaceholder(Pattern.compile(&quot;주소|검색|지하철|단지&quot;));&#13;&#10;            if (byPlaceholder.count() &gt; 0) return byPlaceholder.first();&#13;&#10;        } catch (Exception e) {}&#13;&#10;&#13;&#10;        // 3) role 기반 검색&#13;&#10;        try {&#13;&#10;            Locator byRole = page.getByRole(AriaRole.TEXTBOX, new Page.GetByRoleOptions().setName(Pattern.compile(&quot;주소|검색|지하철|단지&quot;)));&#13;&#10;            if (byRole.count() &gt; 0) return byRole.first();&#13;&#10;        } catch (Exception e) {}&#13;&#10;&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    private Locator trySelectorsOn(Page page) {&#13;&#10;        for (String sel : searchSelectors) {&#13;&#10;            try {&#13;&#10;                Locator loc = page.locator(sel);&#13;&#10;                if (loc.count() &gt; 0) {&#13;&#10;                    Locator first = loc.first();&#13;&#10;                    try {&#13;&#10;                        first.waitFor(new Locator.WaitForOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(3000));&#13;&#10;                    } catch (Exception ignore) {}&#13;&#10;                    if (first.isVisible()) return first;&#13;&#10;                }&#13;&#10;            } catch (Exception ignore) {}&#13;&#10;        }&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;    // URL 쌍을 담는 내부 클래스&#13;&#10;    private static class UrlPair {&#13;&#10;        final String saleUrl;&#13;&#10;        final String rentUrl;&#13;&#10;&#13;&#10;        UrlPair(String saleUrl, String rentUrl) {&#13;&#10;            this.saleUrl = saleUrl;&#13;&#10;            this.rentUrl = rentUrl;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application-prod.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application-prod.properties" />
              <option name="originalContent" value="# Production ?? ?? (Cloudtype ???)&#10;spring.profiles.active=prod&#10;&#10;# ?? ??&#10;server.port=${PORT:8080}&#10;server.servlet.encoding.charset=UTF-8&#10;server.servlet.encoding.enabled=true&#10;server.servlet.encoding.force=true&#10;&#10;# ?? ?? (?? ???)&#10;logging.level.root=INFO&#10;logging.level.com.springboot.knockbe=DEBUG&#10;logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n&#10;&#10;# BDS ??? ??&#10;bds.base-url=https://www.budongsan114.com&#10;bds.response-url-contains=realprice&#10;bds.response-ends-with=.json&#10;bds.timeout.page=30000&#10;bds.timeout.network-idle=15000&#10;&#10;# ??? ???? ?? ??&#10;spring.jpa.open-in-view=false&#10;spring.jackson.generator.ignore-unknown=true&#10;" />
              <option name="updatedContent" value="# Production ?? ?? (Cloudtype ???)&#13;&#10;spring.profiles.active=prod&#13;&#10;&#13;&#10;# ?? ??&#13;&#10;server.port=${PORT:8080}&#13;&#10;server.servlet.encoding.charset=UTF-8&#13;&#10;server.servlet.encoding.enabled=true&#13;&#10;server.servlet.encoding.force=true&#13;&#10;&#13;&#10;# ?? ?? (?? ???)&#13;&#10;logging.level.root=INFO&#13;&#10;logging.level.com.springboot.knockbe=DEBUG&#13;&#10;logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n&#13;&#10;&#13;&#10;# BDS ??? ??&#13;&#10;bds.base-url=https://www.budongsan114.com&#13;&#10;bds.response-url-contains=realprice&#13;&#10;bds.response-ends-with=.json&#13;&#10;bds.timeout.page=30000&#13;&#10;bds.timeout.network-idle=15000&#13;&#10;&#13;&#10;# Playwright ?? ??&#13;&#10;playwright.headless=true&#13;&#10;playwright.browser-path=/ms-playwright/chromium-1124/chrome-linux/chrome&#13;&#10;playwright.args=--no-sandbox,--disable-dev-shm-usage,--disable-gpu,--no-first-run,--disable-background-timer-throttling,--disable-backgrounding-occluded-windows,--disable-renderer-backgrounding&#13;&#10;&#13;&#10;# ??? ???? ?? ??&#13;&#10;spring.jpa.open-in-view=false&#13;&#10;spring.jackson.generator.ignore-unknown=true" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>